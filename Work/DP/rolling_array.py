# 将 2022 拆分成 10 个互不相同的正整数之和的总共方案数有多少

# 动态规划的步骤
# 首先定义基本状态为dp[i][j][k]代表的含义为，目标和为k，能够选取到的最大数为i，选取j个数
# 然后定义状态转移方程，需要分类讨论，分为i>=k和i<k这两种情况
# 如果i<=k，那么dp[i][j][k] = dp[i-1][j-1][k-i] + dp[i-1][j][k]
# 如果i>k，那么dp[i][j][k] = dp[i-1][j][k]
# 初始化，定义最基本子问题的解，即不可再递归的情况。不可再递归的情况，即i=0时，不可再进行递归，只有dp[0][1][0]有问题解，其他情况都无解。


# 使用滚动数组进行空间优化。
# 很容易发现dp[i]只是需要用到dp[i-1]的信息，所以可以按照规定顺序进行计算。
# 所以只需要定义数组dp[j][k]代表的含义是从j个数得到目标和为k的数。
# 需要分类讨论，分为i>=k和i<k这两种情况
# 其中i<=k，那么dp[j][k]+=dp[j-1][k-i]
# 如果i>k，那么dp[j][k]=dp[j][k]，状态不发生改变，所以可以进行剪枝处理。
# 初始化，定义原始子问题的解，除了dp[0][0]=1，其他dp[x][0]都应该为0，也是最原始的子问题的解。


dp = [[0] * 2222 for i in range(11)]
dp[0][0] = 1  

for i in range(1, 2023):
    for j in range(10, 0, -1):
        for k in range(i, 2023):
            dp[j][k] += dp[j-1][k-i]
print(dp[10][2022])

